# 第一章 操作系统

## 操作系统的基本概念

操作系统（operation system，os) 指控制和管理整个计算机系统的硬件和软件资源，并合理的组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是硬件：中央处理器，内存，输入｜输出设备，提供基本的计算资源。

## 操作系统的角色及功能

1. 作为计算机系统资源的管理者：
    * 处理机管理、存储器管理、文件管理、设备管理
    * 目标：安全、高效
1.2  作为用户和计算机之间的接口：
    * 命令接口： 允许用户直接使用。联机命令接口（交互式命令接口，用户说一句，系统做一句）+脱机命令接口（批处理命令接口，用户说一句，系统做一堆。脚本）
    * 程序接口：允许用户通过程序间接使用，由一组系统调用组成（程序接口=系统调用（广义指令））
     例如： user32.dll在程序中调用可以创建窗口等功能，只能通过程序调用
          Gui: 现代操作系统中最流行的图形用户接口1+2=用户接口目标：方便用户使用作为最接近硬件的层次：目标：实现对硬件机器的拓展通常把覆盖了软件的机器称为扩充机器，又称之为虚拟机？
1.3 操作系统实现了对计算机资源的扩充：例如虚拟技术。

## 操作系统的基本特征

1. 并发：操作系统的并发性指计算机中同时存在着多个运行着的程序；并发：指2个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但在微观上是交替发生；
2. 并行：2个或多个事件在同一时刻同时发生当今的计算机一般都是多核CPU，4核意味着允许4个程序并行进行，但是操作系统的并发性依然必不可少。
3. 共享特性：系统中的资源可供内存中多个并发执行的进程共同使用。
    * 互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问。
    * 同时共享方式：允许一个时间段内由多个进程“同时”对他们进行访问。宏观是同时，可能微观是分时共享也可能是同时共享。并发和共享互为存在条件。
4. 虚拟：指把物理上的实体变为若干个逻辑上的对应物。4gb的内存实际可以让远超4gb内存需求的程序同时启用。虚拟存储器技术：空分复用技术（第3章）一个CPU可以同时允许多个程序启动。没有并发性，就谈不上虚拟性。
5. 异步：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一步到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。只有系统拥有了并发性，才可能导致系统的异步性。

## 指令

CPU能够识别的最基础的命令；二进制机器语言。
2种指令

* 普通指令
* 特权指令

2种处理器状态

* 用户态
* 核心态

2种程序

* 内核程序：可以执行特权指令及非特权指令
* 应用程序： 只能执行非特权指令

CPU如何识别特权指令：

## 中断

中断的描述

1. 当发生中断时，CPU立刻进入核心态
2. 当中断发生后，当前运行进程暂停运行，并由操作系统内核对中断进行处理
3. 对于不同中断信号会有不同处理。
4. 中断是让CPU从用户态转入核心态的唯一指令；核心态-》用户态通过执行特权指令将程序状态字从核心态转为用户态。

中断的分类：

* 内中断
* 外中断

## 系统调用

### 功能

1. 设备管理
2. 文件管理
3. 进程控制
4. 进程通信
5. 内存管理

系统调用和库函数的区别
汇编语言  int x 陷入指令，x调用参数
陷入指令只能执行在用户态

## 进程

### 为什么要引入进程

1.程序段：
2.数据段：
进程产生的原因：为了使参与并发执行的每个程序（含数据）能独立运行，在操作系统中必须为之配专门的数据结构，称之为进程控制块（process control block PCB）。系统利用进程来描述进程的基本情况和活动过程，进行控制和管理。这样由程序块，相关数据段和PCB构成了进程实体。2 进程的特征：a. 动态性b.并发性c.独立性d.异步性

2.进程管理中的数据结构（1）系统资源信息表或进程信息表：包含了资源或进程的标识，描述，状态等信息以及一批指针。通过指针将同类资源或系统进程信息表，或同一进程掌握的资源信息表分类链接成不同队列，便于操作系统进行查找。

为了方便操作系统管理，完成各程序并发执行，引入了进程、进程实体店概念；
PCB、程序段、数据段三部分构成了进程实体（进程映像）。
PCB是进程存在的唯一标识。

#### 动态性

1. 进程是程序的一次执行过程；
2. 进程是一个程序及其数据在处理机上顺序执行时发生的活动
3. 进程是具有独立功能的程序在数据集合上运行的过程，他是系统进行资源分配和调度的一个独立单位。

引入进程实体的概念后：
进程是进程实体店运行过程，是系统进行资源分配和调度的独立单位。
进程实体是静态的、进程是动态的。

#### PCB包含的内容

1. 进程描述信息：进程标志符PID（进程被创建时，操作系统分配的唯一的ID）、用户标识符UID；
2. 进程控制和管理信息：进程当前状态、进程优先级
3. 资源分配清单：
    * 程序段指针
    * 数据段指针
    * 键盘
    * 鼠标
4. 处理机相关信息：各种寄存器值（当进程切换时需要被进程当前的运行情况记录下来保存在PCB中，如程序计数器的值表示了当前程序执行到哪一句）

### 进程的组织

在一个系统中，通常有数十、百、千个PCB。为了能对他们有效管理，应该用适当的方式组织PCB
注：进程的组成讨论的是一个进程内部有由哪些部分构成，组织讨论的是多个进程之间的组织方式。

1. 链接方式（队列）

* 操作系统按进程状态分为多个队列;
* 操作系统持有指向各个队列的指针;

1.2 索引方式（索引表）

* 根据进程状态的不同，建立几张索引表
* 操作系统持有指向各个索引表的指针

### 进程的状态

```mermand
graph process_status
A(三种基本状态)-->B1(运行态(running)：占有CPU，并在CPU上运行)
A(三种基本状态)-->B2(就绪态(ready): 已经具备运行条件，但由于没有空闲CPU，暂时不能运行)
A(三种基本状态)-->B3(阻塞态(waiting/blocked)：因等待某一事件而暂时不能运行)
```

![43bebe7892333333628fcbb0e241ed9b.jpeg](evernotecid://59AADDE0-81CE-49C0-9998-80E54FEA1FF9/appyinxiangcom/23494595/ENResource/p23)

#### 基本状态

1. 运行态(running)：占有CPU，并在CPU上运行;
2. 就绪态(ready): 已经具备运行条件，但由于没有空闲CPU，暂时不能运行;
3. 阻塞态(waiting/blocked)：因等待某一事件而暂时不能运行;

#### 进程的另外2种状态

1. 创建态
在内存中产生pcb、数据段、程序段生成阶段，乘坐创建态
2. 终止态
进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB

#### 进程状态的转换

![43bebe7892333333628fcbb0e241ed9b.jpeg](.\1_进程状态切换.png)

* 阻塞态无法直接转为就绪态

* 就绪态无法直接转为阻塞态

* 不可修复错误会将进程状态转为终止态

### 进程的特征

1. 动态性：基本特征。
2. 并发性
3. 独立性：独立运行、独立获得资源、独立接受调度的基本单位。
4. 异步性：各进程按各自独立的，不可预知的速度向前推进。
5. 结构性：进程由

### 进程控制

进程控制主要功能是对系统中的各进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。

#### 如何实现进程控制

用**原语**实现进程控制。原语的特点是执行期间**不允许中断**，只能一气呵成。这种不可被中断的操作，即原子操作。原语采用**\“关中断指令”\**和“开中断指令”实现。
无论哪种原语，无非做三件事：
1.更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB，从PCB恢复运行环境)

* 所有的进程控制原语，都会修改进程状态标志；
* 剥夺当前运行进程的CPU使用权必然需要保存其运行环境;
* 某进程开始运行前，必然要恢复其运行间环境
1.2 将PCB插入合适的队列
1.3 分配|回收资源

创建原语：
![avator](./images/1_%E5%88%9B%E5%BB%BA%E5%8E%9F%E8%AF%AD.png)

撤销原语：
![avator](./images/1_%E6%92%A4%E9%94%80%E5%8E%9F%E8%AF%AD.png)s

阻塞原语和唤醒原语：
![avator](./images/1_%E9%98%BB%E5%A1%9E%E5%8E%9F%E8%AF%AD%E5%92%8C%E5%94%A4%E9%86%92%E5%8E%9F%E8%AF%AD.png)

切换原语:
![avator](./images/1_%E5%88%87%E6%8D%A2%E5%8E%9F%E8%AF%AD.png)

### 进程通信

进程通信就是指进程之间的信息交换。进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的**内存地址空间互相独立**。

#### 进程通信--共享存储

1. 基于数据结构的共享：低级
2. 基于存储区的共享:高级，数据形式及存放位置由进程控制；

#### 进程通信--管道通信

管道是指用于连续读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区。linux中一个pipe对应的大小为4kb

1. 管道只能采用半双工通信，某一时间段内只能实现单向传输。如果要实现双向同时通信，则需要设置两个管道。
2. 各进程要互斥的访问管道。
3. 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。
4. 如果没有写满，不允许读；如果没有读空，不允许写。
5. 数据一旦被读出，就从管道中丢弃，这就意味着读进程最多只有1个，否则可能会有数据读错的情况。

#### 进程通信--消息传递

1. 进程之间的数据交换以格式化的消息(message)为单位。message=消息头+消息体
2. 进程通过操作系统提供的“发送消息|接受消息”2个原语进行数据交换。
3. 2种方式

* 直接通信方式：消息直接挂到接受方的消息队列里
* 简介(邮箱)通信方式：消息先发到中间体（信箱）

![avator](./images/1_%E8%BF%9B%E7%A8%8B_%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92.png)

### 线程

#### 为什么要引入线程

有的进程需要在宏观上做很多事，因此引入了进程。

引入线程之后，线程就成了程序执行流的最小单位，是一个基本的CPU执行单元。

![avator](./images/1_%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5.png)

#### 线程的属性

1. 线程是处理机调度的单位；
2. 多CPU计算机中，各个线程可占用不同的CPU；
3. 每个线程都有一个线程ID、线程控制块(TCB)；
4. 线程也有就绪、阻塞、运行三个基本状态；
5. 线程几乎不拥有系统资源；
6. 同一进程的不同线程间共享进程的资源；
7. 由于共享内存地址空间，同一进程间的线程通信不需要CPU干预
8. 同一进程中的线程切换，不会引起进程切换，系统开销小；
9. 不同进程中的线程切换，会引起进程切换，系统开销大；


#### 线程的实现方式:

1. 用户级线程(User-level Thread,ULT)

![avator](./images/1_%E7%BA%BF%E7%A8%8B_%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B.png)

2. 内核级线程(Kernel-Level Thread,KLT)

![avator](./images/1_%E7%BA%BF%E7%A8%8B_%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B.png)

#### 多线程模型

几个用户级线程映射到几个内核级线程引出该问题：
1. 多对一模型：多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。
- 优点：在用户空间即可完成，线程管理开销小，效率高；
- 缺点：当一个用户级线程阻塞后，整个进程都会被阻塞，并发度并不高。多个线程不可在多核处理机上并行进行

2. 一对一模型：一个用户线程对应一个系统线程。每个用户进程拥有与用户级线程同数量的内核级线程
- 优点：一个线程被阻断后，其他线程仍可运行；
- 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，系统开销大。

3. 多对多模型：n用户级线程映射到m个内核级线程(n>=m).
![avator](./images/1_%E7%BA%BF%E7%A8%8B_%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B_%E5%A4%9A%E5%AF%B9%E5%A4%9A.png)


## 内存
![avator](./images/3_%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93.png)

### 基本分页存储管理的基本概念
连续分配管理方式：为进程分配的必须是一个连续的内存空间；
非连续分配管理方式：为进程分配的可以是非连续的内存空间；


### 逻辑地址转物理地址到基本参数：
1. 逻辑地址到页号；
2. 逻辑地址对应的页内偏移量
3. 逻辑地址对应的页面在内存中存放的地址。

![avator](./images/3_OS%E4%B8%AD%E9%A1%B5%E8%A1%A8%E7%9A%84%E6%A8%A1%E5%9E%8B.png)
基本地址转换机构可以借助**进程的页表**将逻辑地址转换为物理地址.每一页的都是一个页表项(页表项=页号+块号)
通常会在系统中设置一个页表寄存器(PTR),存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的地址
![avator](./images/3_%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F.png)
1. 算出逻辑地址对应的页号；
2. 算出该页号对应页面在内存中的偏移量：操作系统会给每个进程的页面用某种数据结构保存其起始位置(PTR)
3. 算出逻辑地址在页面中的偏移量；
4. 物理地址=页面地址+页内便宜量。

- 操作系统会把**页面大小**一般设置为2的整数幂，方便计算页号和页面偏移量。（内存位置共32位：前20位表示页号，后12位表示页内偏移量)
![avator](./images/3_OS%E5%86%85%E5%AD%98%E9%A1%B5%E9%83%BD%E4%B8%BA2%E7%9A%84%E5%B9%82%E7%9A%84%E5%8E%9F%E5%9B%A0.png)
- 如果每个页面大小为2^k byte(8bits),则末尾k位为页内偏移量，其余部分为页号。
- 在操作系统中每个页表项的长度是相同的，块号可以通过计算得知：
```内存块个数=物理内存大小/页面大小
   内存位置表示需要字节数=内存块个数
   假设为3byte
   如果1个进程由n个页面组成，则该进程的页表总共会占3*n个字节
```
### 基本地址变换机构：用于实现逻辑地址到物理地址到一组**硬件**机构
基本地址变换机构可以借助进程的页表将逻辑地址转为物理地址。
通常会在系统中设置一个**页表寄存器(PTR)**，存放页表在内存中的**起始地址F和页表长度M**。进程未执行时，页表的起始位置和页表长度**放在进程控制块中(PCB)**.当进程被调度时，操作系统内核会把它们放到**页表寄存器**中。
注意：页面大小是2的整数幂。
设页面大小为L，逻辑地址A到物理地址E的变换过程如下:
![avator](./images/3_%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91.png)
1. 计算机内存区域=系统区+用户区；系统区包含了程序控制块(PCB)记录了进程所有信息,进程未执行时包含页表的其实位置和页表长度;
2. 先计算页号P和页内偏移量W，如果用10进制换算(P=A/L,W=A%L;但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快的得到二进制表示的页号、页内偏移量)
3. 先用页号去查询PTR中的页表长度M，查询页号是否合法（页号>=M时非法)；如非法，则报越界异常；如合法，到第4步
4. 依据PTR中的页表起始地址，查询页表，找到页号对应的页表项，确定内存块号；
4. 以内存块号和页内偏移量得到物理地址：E=b*L+W; b:内存块号；L：页面长度；W：页内偏移量。对于计算机来说只用把内存块号b、页面偏移量W用二进制表示，拼接起来就是最终物理地址了。

几个基本概念：
- 页表项长度： 每个页表项占多大的存储空间
- 页表长度： 页面中有几个页表项，即有几页
- 页面大小L：一个页面占多大的存储空间，由操作系统决定；
- 逻辑地址A

#### 总结
在分页存储管理系统中(页式管理)，只要确定了每个页面大小，逻辑地址结构就确定了，因此，**页式地址是一维的**。即，只要给出一个逻辑地址，系统就可以自动算出页号、页内偏移量 2个部分。并不需要显示告诉系统这个逻辑地址中，页内偏移量占多少位。

#### 对页表项大小的进一步探讨
理论上，页表项长度为3b即可表示内存块号的范围，但是为了方便页表的查询，常常会让页表项多占更多的字节，使得每个页面恰好可以装得下整个页表项，避免产生碎片。
![avator](./images/3_%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%9A%84%E5%AE%9E%E9%99%85%E4%B8%8E%E7%90%86%E8%AE%BA.png)

### 局部性原理
时间局部性：如果执行了某条指令，切不久后这条指令很有可能再次执行，如果某个数据被访问过，不久后该数据可能被再次访问。例如循环。
空间局部性：如果程序访问了某个存储单元，在不久之后，其附近的存储单元页可能被再次访问。例如：数组结构的数据。

使用基本地址变换机构中，每次都要访问一个逻辑地址，都需要查询内存中的页表，由于局部性原理，可能连续多次查到的都是同一个页表中的页表项。既然如此，可以利用局部性特性减少访问页表的次数。

#### 什么是快表(TLB)
快表，又称联想寄存器(TLB),是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程，与此对应，内存中的页表常称为慢表。
1. 快表的访问逻辑
![avator](./images/3_%E5%BF%AB%E8%A1%A8%E4%BD%BF%E7%94%A8%E9%80%BB%E8%BE%91.png)
2. 快表的更新逻辑：
在慢表中找到页表项后，应同时将其存入快表，以便之后的访问；
如果快表已满，则必须按**一定的算法**对旧的页表进行替换。

总结：
![avator](./images/3_%E5%BF%AB%E8%A1%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93.png)

### 两级页表
#### 单极页表存在的问题
一个支持32位逻辑地址，采用分页存储管理，页面大小为4kb，页表项长度为4b。
4kb=2^12B,因此页内地址要用12位表示，生于20位表示页号。
因此，该系统中用户进程最多有2^20页，相应的，一个进程的页表中，最多会有2^20=1M=1048576个页表项。所以一个页表最大需要2^20*4B.所以一个页表最大需要2^20*4B=2^22B的空间。
需要2^22/2^12= 2^10个页框存储页表。

根据页号查询页表的方法：K号页对应的页表项存放位置=页表起始位置+K*4。
因此要所有的页表项连续存放的基础上才能实现。
比较占空间，也丧失了离散存放的优点。

#### 解决方案
将页表进行分组，使每个内存块刚好可以放入1个分组(比如上述例子中，页面大小4KB，每个页表项4B，每个页面可以存放1K个页表项，因此每1K个页表项为1组，刚好可以放入一个内存块。再将各组离散放到各个内存块中。)
另外，要为离散分配的页表再建立一张页表，称为页目录表，或外层页表，顶层页表。

二级页表的地址转换方示意图:
![avator](./images/3_%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8.png)

PS：若想访问的页面不在内存中，则产生缺页中断(内中断)，然后将目标页面从外存调入内存。
1. 若采用多级页表机制，则各级页表的大小不能超过一个页面。
2. 2级页表的访存次数分析(假设不存在快表)：
第一次访存：访问内存中的页目录表；
第二次访存：访问内存中的二级页表
第三次访存：访问目标单元。


![avator](./images/3_2%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%9A%84%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93.png)
newK5BRgFKV

### 基本分段存储管理

#### 什么是分段
进程的地址空间，会按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名(在低级语言中，程序员使用段名来编程)，每段从0开始编址。
分段系统中逻辑地址=段号+段内地址
- 段号的位数：决定每个进程最多可以有几个段
- 段内地址位数：决定了每个段段最大长度
#### 什么是段表
段表：记录各个逻辑段在内存中存放的位置；类似于页表
段表=段号(隐藏不占空间)+段长+基址
1.每个段对应一个段表项，其中记录了该段在内存中的起始位置(又称“基址”)和段的长度。
2.各个段表项的长度相同。例如：某系统按字节寻址，采用分段存储管理，逻辑地址结构为(段号16位，段内地址16位)，因此用16位即可表示最大段长。物理内存大小为4GB(可用32位表示整个物理内存地址空间)。因此，可以让每个段表项占16+32=48位，即6B。由于段表项长度相同，因此段号可以隐藏，不占存储空间。
若段表存放的起始位置为M，则K号段对应的段表项存放的地址为M+K*6
#### 如何实现地址变换
![avator](./images/3_%E6%AE%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png)

需要进行2次越界检查：段号越界；段长越界
#### 分段、分页管理的对比

页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，**对用户是不可见的。**
段是信息的逻辑单位。分段的主要目的是为了更好的满足用户需求，方便编程。一个段通常包含着一组属于一个逻辑块的信息。分段是对用户可见的，用户编程时需要显示地给出段名。
页的大小是固定且由系统决定。段的长度却不固定，决定于用户编写的程序。
分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。
分段的用户进程地址是2维的，需要给出段名+段内地址。例如load 1，<A>；

分段比分页更容易实现信息共享和保护。

![avator](./images/3_%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93.png)


### 段页式管理方式
#### 分页和分段方式中最大的优缺点
||优点|缺点|
|--|--|--|
|分页管理|内存空间利用率高，不会产生外部碎片，只会有少量内部碎片|不方便按照逻辑模块实现信息的共享和保护|
|分段管理|很方便按逻辑模块实现信息的共享和保护|如果段长过大，为其分配连续空间会很不方便。另外，该方式会产生外部碎片|
#### 分段+分页的结合-段页式管理方式
![avator](./images/3_%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

段页式系统的逻辑地址=段号+页号+页内偏移量
- 段号的位数决定了进程的段数
- 页号的位数决定了每个段的最大页数
- 页内偏移量决定了页面大小

“分段”对用户是可见的，程序员编程时需要显式的给出段号、段内地址。而将各段“分页”对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。
因此段页管理的地址结构式二维的

#### 段表、页表
1个进程对应1个段表多个页表
![avator](./images/3_%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E7%9A%84%E6%80%BB%E7%BB%93.png)

### 虚拟内存(虚拟内存技术)

#### 传统存储管理的特征、特点
1. 一次性：作业必须一次性全部装入内存后才能开始运行；大作业无法运行；多道程序并发度下降。
2. 驻留性：作业一旦被加载，就会一直驻留在内存中。

#### 局部性原理
1. 时间局部性:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能被再次访问。(因为程序大量循环)
2. 空间局部性：一旦程序访问了某个存储单元，在不久后，其附近的单元也很有可能被访问。(因为很多数据在内存中都是连续存放的，并且程序指令也是顺序在内存中存放的)

速度：
寄存器>高速缓存>内存>外存   

#### 虚拟内存的定义和特征
基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。
在程序执行过程中，当所访问的信息不在内存时，由os负责将所需信息从外存调入内存，然后执行程序。
若内存空间不够，由os将内存中暂时不用的信息换出到外存。
在os的管理下，在用户看来似乎有一个比实际大得多大内存，这就是虚拟内存。

ps:虚拟内存大最大容量是由计算机的地址结构(cpu寻址范围)确定的
虚拟内存的实际容量=min(内存和外存容量之和，CPU的寻址范围)

虚拟内存的特征：
1. 多次性：无需在作业运行时一次性装入内存。
2. 对换性：在作业运行时，无用数据无需常驻内存。
3. 虚拟性：从逻辑上扩充了内存的容量。

#### 如何实现虚拟内存技术
需要建立在离散分配的内存管理方式基础上。(分页、分段、段页式)
![avator](./images/3_%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF%E7%89%B9%E6%9C%89%E7%9A%84os%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82.png)

#### 请求分页管理方式(当所访问信息不在内存时，由os负责将信息从外存调入内存)
1. 页表机制
相对于基本分页管理的页表来说，请求分页管理的页表增加了以下4个字段：
- 状态位：是否已调入内存
- 访问字段： 可记录最近被访问过几次，或记录上次的访问时间，供换算法选择换出页面做参考
- 修改位： 页面调入后是否被修改过
- 外存地址：页面在外存存储的地址

在请求分页系统中，当访问的页面不在内存时，会产生缺页中断信号。然后由os的缺页中断程序处理中断。
此时缺页的进程阻塞，放入阻塞队列，调页完成之后再将其唤醒，放回就绪队列。
如果内存中有空闲块
如果内存中无空闲块，则由页面置换算法，选择一个页面淘汰，若该页面在内存期间被修改过，则需要回写外存。未修改过则不用。
2. 缺页中段机构
内中段和外中断的分类：
![avator](./images/3_%E5%86%85%E4%B8%AD%E6%96%AD%E5%92%8C%E5%A4%96%E4%B8%AD%E6%96%AD.png)
3. 地址变换机构
请求分页地址变换机构需要关注的步骤：
a. 请求调页(查到页表项时进行判断)
b. 页面置换(需要调入页面，但没有空闲块时进行)
c. 修改请求页表中新增的页表项。

快表中的页表项，说明该页表项已被载入内存中。
![avator](./images/3_%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%9A%84%E5%AF%BB%E5%9D%80%E6%B5%81%E7%A8%8B.png)
ç 页面置换算法
![avator](./images/3_%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E7%9A%84%E7%A7%8D%E7%B1%BB.png)
##### 最佳置换算法(opt)
 每次选择的页面都是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低缺页率。
 需要有需访问页面的队列信息，操作系统无法得知，该算法是理想算法。
##### 先进先出(fifo)
每次选择淘汰的页面是最早进入内存的页面。

实现方法：把调入内存的页面根据调入的顺序排成一个队列，队列的最大长度取决于系统为进程分配了多少个内存块。
balady异常：当为进程分配内存块增加时，缺页次数不减反增的现象。
只有fifo算法会产生belady异常，算法性能比较差。
##### 最近最久未使用置换算法(LRU)
每次淘汰的页面是最近最久未使用的页面。

实现方式：在每个页面的页表项中记录该页面自上次访问以来所经历的时间t，当需要淘汰时，选择现有页面中t最大的。
缺点：需要硬件支持，快表需要增加记录时间的位置。算法开销大。
优点：性能最好
![avator](./images/3_LRU%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png)
##### 时钟置换算法(clock)
又称最近未使用算法(NRU),
实现方式：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成1个循环队列，当某个页面被访问时，其访问位置位1，当需要淘汰页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1置为0，继续下一轮检查。最多进行2轮检查。
##### 改进型时钟置换算法
![avator](./images/3_%E6%94%B9%E8%BF%9B%E6%97%B6%E9%92%9F%E5%9E%8B%E7%AE%97%E6%B3%95.png)
在时钟置换基础上，增加判断条件，页面是否被修改过，有限置换未被修改的页面。页表项包含访问位、修改位。优先淘汰(0,0)的页面，最多扫描4轮。


#### 页面分配策略
##### 页面分配、置换策略
驻留集：请求分页管理中给进程分配的物理块的集合。
若驻留集太小，会导致缺页频繁，系统要花大量时间来处理缺页，实际用于进程推进的时间很少；
驻留集太大，则会导致系统并发度下降，资源利用率低。

固定分配：驻留集大小不变。
可变分配：反之

局部置换：发生缺页时只能选进程自己的驻留集；
全局置换：可以将os保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。

搭配方式有：
- 固定分配，局部置换： os为每个进程分配一定数量的物理块，在整个运行期间不改变。若进程缺页，则在自己分得的物理块中调出。缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。

- 可变分配，局部置换： os为每个进程分配一定数量的物理块。os会保持一个空闲物理块队列。当某个进程发生缺页时，从空闲物理块中取出一块分配给进程；若无空闲物理块，则可选择一个**未锁定**的页面换出外存，再将该物理块分配给缺页进程。缺点：被选中的进程拥有的物理块会减少，缺页率会增加。

- 可变分配，全局置换：os为每个进程分配一定数量的物理块。发生缺页时，只允许从自己的物理块中换出外存。如果进程在运行中频繁缺页，os则会为该进程多分配几个物理块，直至达到合理的缺页率；若有进程缺页率特别低，则适当减少分配的物理块。


#### 合适调入页面

1. 预调页策略(运行前调入）：根据局部性原理，一次调入若干相邻页面，预测度50%。这种策略主要用于进程首次调入，由程序员指定应先调入哪些部分。

2. 请求调页策略（运行时调入）：进程在运行期间发现缺页时才将所缺的页面调入内存。这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都需要io操作，因此i/o开销较大。


#### 从何处调入页面
![avator](./images/3_%E5%AF%B9%E6%8D%A2%E5%8C%BA%E2%80%94%E6%96%87%E4%BB%B6%E5%8C%BA.png)


#### 抖动（颠簸）现象

刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存的现象。
产生原因：进程频繁访问的页面数目高于可用物理块。

在此基础上，有科学家提出了工作集概念。
驻留集：请求分页管理中给进程分配的物理块的集合。
工作集：指在某段时间间隔里，进程实际访问页面的集合。
![avator](./images/3_%E5%B7%A5%E4%BD%9C%E9%9B%86%E7%9A%84%E8%AE%A1%E7%AE%97.png)


## 文件管理
### 文件的属性
- 文件名：同层目录不允许重复
- 标识符： 一个系统内的各文件标识符唯一
- 类型：  指明文件的类型
- 位置： 文件存放路径（让用户使用）、在外存中的地址（对os使用，对用户不可见）
- 大小
- 创建时间、上次修改时间
- 保护信息： 对文件进行保护的访问控制信息

保护权限有
windows： 完全控制，修改，读取和执行，读取，写入

### 文件内部数据的组织
1. 无结构文件（如文本文件），由一些二进制或者字符流组成，又称流式文件。
2. 有结构文件，由一组相似的记录构成，又称记录式文件

### os提供的用户操作文件的功能：
1. 创建文件：“create系统调用“
2. 读文件： “read系统调用”
3. 写文件： “write系统调用“
4. 删除文件： “delete系统调用“
5. 打开文件： “open系统调用”
6. 关闭文件： “close系统调用”

### 从上往下看，文件如何放到外存中
![avator](./images/4_%E6%96%87%E4%BB%B6%E5%9C%A8%E5%A4%96%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8.png)

### 其他需要os实现的文件管理功能
1. 文件共享
2. 文件保护
### 文件的逻辑结构
1. 无结构文件
文件内部的数据就是一系列二进制流或字符流组成，又称流式文件。
2. 有结构文件
由一组相似的记录组成，又称“记录式文件”。每条记录又由若干个数据项组成。如数据库表文件。
一般来说，每条记录有一个数据项可作为关键字。
根据记录长度（占用的存储空间）是否相等，又可分为定长记录和可变长记录。

#### 顺序文件
文件中的记录一个接一个地顺序存储（逻辑上），记录可以是定长或者可变定长。各个记录在物理上可以顺序存储或链式存储。

顺序文件又可分为：
1. 串结构：记录之间的顺序和关键字无关，通常‘按记录存入的时间决定记录的顺序。（顺序写）
2. 顺序结构：记录之间的顺序按关键字顺序排列。

##### 能否实现随机访问
![avator](./images/4_%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6%E8%83%BD%E5%90%A6%E5%AE%9E%E7%8E%B0%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE.png)

PS.一般来说，顺序文件指的是物理上顺序存储的的文件。顺序文件的缺点是：增加/删除记录比较难；串结构比较简单。

#### 索引文件
解决可变长文件，要找到第i个记录需要顺序查找前i-1个记录，效率低的问题。
![avator](./images/4_%E7%B4%A2%E5%BC%95%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86.png)
- 给顺序文件建立一张索引表，是定长记录的格式，可以快速找到第i个记录对应的索引项。
- 可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按关键字对半查找。
- 每当要增加/删除一个记录时，需要对索引表进行修改。
- 索引文件有很快的检索速度。

另外可以用不同的数据项建立多个索引表。

索引文件的缺点：
每个记录对应一个索引项表，如果每条记录很小，例如（8byte），但没个索引表项需要占32个字节，为记录大小的4倍，则很不合理。
因此可以引入索引顺序文件：
##### 索引顺序文件
索引顺序文件中会为文件建立索引表，但不同的是，并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项。

索引顺序文件可以减少顺序查找的次数。如有10000条记录，平均顺序查询是5000次，采用一级索引顺序表，则可以将5000次减少为1000次。示意如图：
![avator](./images/4_%E4%B8%80%E7%BA%A7%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90.png)
如果想进一步减少平均查找次数，可以建立多级索引表

### 文件目录
![文件目录的知识总结](./images/4_%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9A%84%E6%80%BB%E7%BB%93.png)
#### 文件控制块

目录文件本身就是一种有结构的文件，由一条条记录组成。每条记录对应一个该放在该目录下的文件。
目录文件中的一条记录就是一个文件控制块(FCB).
FCB的有序集合称为“文件目录”，一个FCB就是一个文件目录项。FCB中包含了文件的基本信息(文件名、物理地址、逻辑结构、物理结构等)，存续控制信息，使用信息。

需要对目录进行哪些操作
- 搜索：
- 创建文件
- 删除文件
- 修改目录
- 显示目录
#### 目录结构--2级目录结构
![avator](./images/4_%E4%B8%A4%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png)

#### 目录结构--树形目录结构
树形目录结构不便于实现文件共享，在此基础上产生了无环图目录结构。
可以用不同的文件名指向同一个文件。
- 需要为每个共享结点设置一个共享计数器。

#### 索引结点（FCB的改进）
![avator](./images/4_%E7%B4%A2%E5%BC%95%E7%BB%93%E7%82%B9%E7%9A%84%E6%94%B9%E8%BF%9B.png)

当找到文件名对应的目录项时，才需要把索引结点调入内存，索引结点记录了文件的各种信息。包括文件在外存中存放的地址

### os需要对磁盘进行哪些管理

非空闲磁盘块的管理、空闲磁盘块的管理

#### 文件的物理结构（文件分配方式）
![文件块](./images/4_%E6%96%87%E4%BB%B6%E5%9D%97%E7%9A%84%E5%9B%BE%E7%A4%BA.png)
<font color=black>
文件块：文件的逻辑地址空间也被分为了一个一个的文件块
文件的逻辑地址也可以表示为：逻辑块号+块内地址
1. 连续分配：要求每个文件在磁盘上占用一组连续的块。
```text
* 物理块号=起始块号+逻辑块号。支持顺序访问和直接访问。
* 优点：顺序读/写时速度最快
* 缺点：拓展文件的开销大；存储空间利用率低，会产生难以利用的磁盘碎片。可以“紧凑”来处理碎片，但需要耗费很大代价。
```
2. 链接分配：可以为文件分配离散的磁盘块，用指针连接，分为隐式链接和显示链接。
</font>
![链接分配-隐式链接](./images/4_%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D-%E9%9A%90%E5%BC%8F%E9%93%BE%E6%8E%A5.png)
- 优点： 不会产生碎片问题，拓展方便
- 缺点： 访问速度慢
![链接分配-显式链接](./images/4_%E9%93%BE%E6%8E%A5%E5%88%86%E9%85%8D-%E6%98%BE%E5%BC%8F.png)
- 把用于链接文件各物理块的指针显式存放在一张表中，即文件分配表(FAT, file allocation table);FCB中仅记录起始块号。
- FAT表是常驻内存，一个磁盘一张，
- 即支持顺序访问，又支持随机访问
- 优点： 不会产生碎片问题，访问速度又比隐式快
- 缺点： FAT需要占用一定内存空间。
3. 索引分配：允许文件离散的分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各逻辑块对应的物理块(类似内存块里中的页表--建立逻辑页面到物理页之间的映射关系)。索引表存放的磁盘块称为“索引块”，文件数据存放的磁盘块称为“数据块”。
![索引分配](./images/4_%E7%B4%A2%E5%BC%95%E5%88%86%E9%85%8D.png)
注： 在显式链接分配方式中，文件分配表FAT是一个磁盘一张。而索引分配中是，索引表是每个文件一张。
FCB(目录中)需要记录文件的索引块是几号磁盘，其中存放了文件的索引表 
- 优点： 即支持顺序访问，又支持随机访问
- 缺点： 每个文件的索引表会消耗一定磁盘空间。
如果1个文件占用的磁盘块超过了一个磁盘块可以容纳的索引表项的个数，该如何解决？
- 链接方案：索引表链接
- 多层索引：建立多层索引(原理类似于多级页表)。使第一层索引块指向第二层索引块，还可以根据文件大小的要求再建立第三层，第四层索引块。
- 混合索引
### 文件的  